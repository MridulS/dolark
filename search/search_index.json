{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DolARK Introduction DolARK is an experimental project to solve heterogenous agents models with infinitely lived agents. It relies on Dolo to model individual agents behavious and extends its modeling language to describe distributions of agents and aggregate dynamics. We aim to support the following basic cases: heterogenous preferences, i.i.d. idiosyncratic shocks no aggregate risk homogenous preferences, perturbation w.r.t. aggregate risk homogenous preferences, dimension reduction of the state-space a la Krussell-Smith Frequently Asked Questions No question was ever asked. Certainly because it's all very clear. Developper Corner Contribute to the documentation Documentation is contained in the docs subdirectory. In order to develop it locally: pip install mkdocs pip install pymdown-extensions Then mkdocs serve from within DolARK repository. On a regular basis, latest version is deployed to github pages pages (for now) using mkdocs gh-deploy . Notebooks are written as Python files and can be opened with Jupyter using the jupytext extension.","title":"Home"},{"location":"#dolark","text":"","title":"DolARK"},{"location":"#introduction","text":"DolARK is an experimental project to solve heterogenous agents models with infinitely lived agents. It relies on Dolo to model individual agents behavious and extends its modeling language to describe distributions of agents and aggregate dynamics. We aim to support the following basic cases: heterogenous preferences, i.i.d. idiosyncratic shocks no aggregate risk homogenous preferences, perturbation w.r.t. aggregate risk homogenous preferences, dimension reduction of the state-space a la Krussell-Smith","title":"Introduction"},{"location":"#frequently-asked-questions","text":"No question was ever asked. Certainly because it's all very clear.","title":"Frequently Asked Questions"},{"location":"#developper-corner","text":"","title":"Developper Corner"},{"location":"#contribute-to-the-documentation","text":"Documentation is contained in the docs subdirectory. In order to develop it locally: pip install mkdocs pip install pymdown-extensions Then mkdocs serve from within DolARK repository. On a regular basis, latest version is deployed to github pages pages (for now) using mkdocs gh-deploy . Notebooks are written as Python files and can be opened with Jupyter using the jupytext extension.","title":"Contribute to the documentation"},{"location":"equilibrium/","text":"Time-invariant equilibrium Recall the model written in section X. The agents decision depends on the values processes, which are pinned down by aggregate conditions. These conditions are fixed in an additional equilibrium section. Let us start from an example: yaml symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k python class KrussellSmith(AggregateModel): symbols = dict( exogenous = [\"z\"], aggregate = [\"K\"], parameters = [\"A\", \"alpha\", \"delta\", '\u03c1'] ) calibration_dict = dict( A = 1, alpha = 0.36, delta = 0.025, K = 40, z = 0, \u03c1 = 0.95 ) def \u03c4(self, m, p): # exogenous process is assumed to be deterministic \u03c1 = p[3] return m*\u03c1 def definitions(self, m: 'n_e', y: \"n_y\", p: \"n_p\"): from numpy import exp z = m[0] K = y[0] A = [0] alpha = p[1] delta = p[2] N = 1 r = alpha*exp(z)*(N/K)**(1-alpha) - delta w = (1-alpha)*exp(z)*(K/N)**(alpha) return {'r': r, \"w\": w} def \ud835\udc9c(self, m0: 'n_e', \u03bc0: \"n_m.N\" , xx0: \"n_m.N.n_x\", y0: \"n_y\", p: \"n_p\"): import numpy as np kd = sum( [float((\u03bc0[i,:]*xx0[i,:,0]).sum()) for i in range(\u03bc0.shape[0])] ) aggres_0 = np.array( [kd - y0[0] ]) return aggres_0 Now, a model with idiosyncratic hetorogeneity: yaml symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k heterogeneity: \u03b2: Uniform: a: 0.95 b: 0.96","title":"Equilibrium"},{"location":"equilibrium/#time-invariant-equilibrium","text":"Recall the model written in section X. The agents decision depends on the values processes, which are pinned down by aggregate conditions. These conditions are fixed in an additional equilibrium section. Let us start from an example: yaml symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k python class KrussellSmith(AggregateModel): symbols = dict( exogenous = [\"z\"], aggregate = [\"K\"], parameters = [\"A\", \"alpha\", \"delta\", '\u03c1'] ) calibration_dict = dict( A = 1, alpha = 0.36, delta = 0.025, K = 40, z = 0, \u03c1 = 0.95 ) def \u03c4(self, m, p): # exogenous process is assumed to be deterministic \u03c1 = p[3] return m*\u03c1 def definitions(self, m: 'n_e', y: \"n_y\", p: \"n_p\"): from numpy import exp z = m[0] K = y[0] A = [0] alpha = p[1] delta = p[2] N = 1 r = alpha*exp(z)*(N/K)**(1-alpha) - delta w = (1-alpha)*exp(z)*(K/N)**(alpha) return {'r': r, \"w\": w} def \ud835\udc9c(self, m0: 'n_e', \u03bc0: \"n_m.N\" , xx0: \"n_m.N.n_x\", y0: \"n_y\", p: \"n_p\"): import numpy as np kd = sum( [float((\u03bc0[i,:]*xx0[i,:,0]).sum()) for i in range(\u03bc0.shape[0])] ) aggres_0 = np.array( [kd - y0[0] ]) return aggres_0 Now, a model with idiosyncratic hetorogeneity: yaml symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k heterogeneity: \u03b2: Uniform: a: 0.95 b: 0.96","title":"Time-invariant equilibrium"},{"location":"krussell_smith/","text":"Krussell & Smith algorithm","title":"Krussell-Smith"},{"location":"krussell_smith/#krussell-smith-algorithm","text":"","title":"Krussell &amp; Smith algorithm"},{"location":"perturbation/","text":"Perturbation w.r.t. aggregate state.","title":"Perturbation"},{"location":"perturbation/#perturbation-wrt-aggregate-state","text":"","title":"Perturbation w.r.t. aggregate state."},{"location":"shocks/","text":"Shocks The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks continuous auto-correlated process discrete markov chain. Exogenous shock processes are specified in the section exogenous of a yaml file.. Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Here are some examples for each type of shock: IID Distributions Univariate distributions IID Normal The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted, thanks to the greek_tolerance function. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu IID LogNormal Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu Uniform Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max Beta If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1 Bernouilli Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3 Multivariate distributions Normal (multivariate) Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1] Mixtures For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. ... exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3]) Continuous Autoregressive Process AR1 / VAR1 For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]] Markov chains Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] Product We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof). Conditional processes Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Discretization methods for continous shocks To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Shocks"},{"location":"shocks/#shocks","text":"The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks continuous auto-correlated process discrete markov chain. Exogenous shock processes are specified in the section exogenous of a yaml file.. Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Here are some examples for each type of shock:","title":"Shocks"},{"location":"shocks/#iid-distributions","text":"","title":"IID Distributions"},{"location":"shocks/#univariate-distributions","text":"","title":"Univariate distributions"},{"location":"shocks/#iid-normal","text":"The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted, thanks to the greek_tolerance function. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu","title":"IID Normal"},{"location":"shocks/#iid-lognormal","text":"Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu","title":"IID LogNormal"},{"location":"shocks/#uniform","text":"Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max","title":"Uniform"},{"location":"shocks/#beta","text":"If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1","title":"Beta"},{"location":"shocks/#bernouilli","text":"Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3","title":"Bernouilli"},{"location":"shocks/#multivariate-distributions","text":"","title":"Multivariate distributions"},{"location":"shocks/#normal-multivariate","text":"Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1]","title":"Normal (multivariate)"},{"location":"shocks/#mixtures","text":"For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. ... exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3])","title":"Mixtures"},{"location":"shocks/#continuous-autoregressive-process","text":"","title":"Continuous Autoregressive Process"},{"location":"shocks/#ar1-var1","text":"For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]]","title":"AR1 / VAR1"},{"location":"shocks/#markov-chains","text":"Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]]","title":"Markov chains"},{"location":"shocks/#product","text":"We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof).","title":"Product"},{"location":"shocks/#conditional-processes","text":"Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]]","title":"Conditional processes"},{"location":"shocks/#discretization-methods-for-continous-shocks","text":"To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Discretization methods for continous shocks"}]}