{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DolARK Introduction DolARK is an experimental project to solve heterogenous agents models with infinitely lived agents. It relies on Dolo to model individual agents behavious and extends its modeling language to describe distributions of agents and aggregate dynamics. We aim to support the following basic cases: heterogenous preferences, i.i.d. idiosyncratic shocks no aggregate risk homogenous preferences, perturbation w.r.t. aggregate risk homogenous preferences, dimension reduction of the state-space a la Krussell-Smith Frequently Asked Questions No question was ever asked. Certainly because it's all very clear. Developper Corner Contribute to the documentation Documentation is contained in the docs subdirectory. In order to develop it locally: pip install mkdocs pip install pymdown-extensions Then mkdocs serve from within DolARK repository. On a regular basis, latest version is deployed to github pages pages (for now) using mkdocs gh-deploy . Notebooks are written as Python files and can be opened with Jupyter using the jupytext extension.","title":"Home"},{"location":"#dolark","text":"","title":"DolARK"},{"location":"#introduction","text":"DolARK is an experimental project to solve heterogenous agents models with infinitely lived agents. It relies on Dolo to model individual agents behavious and extends its modeling language to describe distributions of agents and aggregate dynamics. We aim to support the following basic cases: heterogenous preferences, i.i.d. idiosyncratic shocks no aggregate risk homogenous preferences, perturbation w.r.t. aggregate risk homogenous preferences, dimension reduction of the state-space a la Krussell-Smith","title":"Introduction"},{"location":"#frequently-asked-questions","text":"No question was ever asked. Certainly because it's all very clear.","title":"Frequently Asked Questions"},{"location":"#developper-corner","text":"","title":"Developper Corner"},{"location":"#contribute-to-the-documentation","text":"Documentation is contained in the docs subdirectory. In order to develop it locally: pip install mkdocs pip install pymdown-extensions Then mkdocs serve from within DolARK repository. On a regular basis, latest version is deployed to github pages pages (for now) using mkdocs gh-deploy . Notebooks are written as Python files and can be opened with Jupyter using the jupytext extension.","title":"Contribute to the documentation"},{"location":"equilibrium/","text":"Time-invariant equilibrium Recall the model written in section X. The agents decision depends on the values processes, which are pinned down by aggregate conditions. These conditions are fixed in an additional equilibrium section. Let us start from an example: yaml symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k python class KrussellSmith(AggregateModel): symbols = dict( exogenous = [\"z\"], aggregate = [\"K\"], parameters = [\"A\", \"alpha\", \"delta\", '\u03c1'] ) calibration_dict = dict( A = 1, alpha = 0.36, delta = 0.025, K = 40, z = 0, \u03c1 = 0.95 ) def \u03c4(self, m, p): # exogenous process is assumed to be deterministic \u03c1 = p[3] return m*\u03c1 def definitions(self, m: 'n_e', y: \"n_y\", p: \"n_p\"): from numpy import exp z = m[0] K = y[0] A = [0] alpha = p[1] delta = p[2] N = 1 r = alpha*exp(z)*(N/K)**(1-alpha) - delta w = (1-alpha)*exp(z)*(K/N)**(alpha) return {'r': r, \"w\": w} def \ud835\udc9c(self, m0: 'n_e', \u03bc0: \"n_m.N\" , xx0: \"n_m.N.n_x\", y0: \"n_y\", p: \"n_p\"): import numpy as np kd = sum( [float((\u03bc0[i,:]*xx0[i,:,0]).sum()) for i in range(\u03bc0.shape[0])] ) aggres_0 = np.array( [kd - y0[0] ]) return aggres_0 Graphical represenation vegaEmbed('#view','../graphs/distrib.json'); heterogeneity Now, a model with idiosyncratic heterogeneity: symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k heterogeneity: \u03b2: Uniform: a: 0.95 b: 0.96","title":"Equilibrium"},{"location":"equilibrium/#time-invariant-equilibrium","text":"Recall the model written in section X. The agents decision depends on the values processes, which are pinned down by aggregate conditions. These conditions are fixed in an additional equilibrium section. Let us start from an example: yaml symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k python class KrussellSmith(AggregateModel): symbols = dict( exogenous = [\"z\"], aggregate = [\"K\"], parameters = [\"A\", \"alpha\", \"delta\", '\u03c1'] ) calibration_dict = dict( A = 1, alpha = 0.36, delta = 0.025, K = 40, z = 0, \u03c1 = 0.95 ) def \u03c4(self, m, p): # exogenous process is assumed to be deterministic \u03c1 = p[3] return m*\u03c1 def definitions(self, m: 'n_e', y: \"n_y\", p: \"n_p\"): from numpy import exp z = m[0] K = y[0] A = [0] alpha = p[1] delta = p[2] N = 1 r = alpha*exp(z)*(N/K)**(1-alpha) - delta w = (1-alpha)*exp(z)*(K/N)**(alpha) return {'r': r, \"w\": w} def \ud835\udc9c(self, m0: 'n_e', \u03bc0: \"n_m.N\" , xx0: \"n_m.N.n_x\", y0: \"n_y\", p: \"n_p\"): import numpy as np kd = sum( [float((\u03bc0[i,:]*xx0[i,:,0]).sum()) for i in range(\u03bc0.shape[0])] ) aggres_0 = np.array( [kd - y0[0] ]) return aggres_0 Graphical represenation vegaEmbed('#view','../graphs/distrib.json');","title":"Time-invariant equilibrium"},{"location":"equilibrium/#heterogeneity","text":"Now, a model with idiosyncratic heterogeneity: symbols: exogenous: [z] aggregate: [K] parameters = [A, alpha, delta, \u03c1] ) calibration: A: 1 alpha: 0.36 delta: 0.025 K: 40 z: 0 \u03c1: 0.95 exogenous: !AR1 \u03c1: \u03c1 \u03c3: \u03c3 equilibrium: K = k heterogeneity: \u03b2: Uniform: a: 0.95 b: 0.96","title":"heterogeneity"},{"location":"krussell_smith/","text":"Krussell & Smith algorithm","title":"Krussell-Smith"},{"location":"krussell_smith/#krussell-smith-algorithm","text":"","title":"Krussell &amp; Smith algorithm"},{"location":"perturbation/","text":"Perturbation w.r.t. aggregate state.","title":"Perturbation"},{"location":"perturbation/#perturbation-wrt-aggregate-state","text":"","title":"Perturbation w.r.t. aggregate state."},{"location":"shocks/","text":"Shocks The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks continuous auto-correlated process discrete markov chain. Exogenous shock processes are specified in the section exogenous of a yaml file.. Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Here are some examples for each type of shock: IID Distributions Univariate distributions IID Normal The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted, thanks to the greek_tolerance function. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu IID LogNormal Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu Uniform Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max Beta If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1 Bernouilli Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3 Multivariate distributions Normal (multivariate) Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1] Mixtures For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. ... exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3]) Continuous Autoregressive Process AR1 / VAR1 For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]] Markov chains Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] Product We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof). Conditional processes Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Discretization methods for continous shocks To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Shocks"},{"location":"shocks/#shocks","text":"The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks continuous auto-correlated process discrete markov chain. Exogenous shock processes are specified in the section exogenous of a yaml file.. Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Here are some examples for each type of shock:","title":"Shocks"},{"location":"shocks/#iid-distributions","text":"","title":"IID Distributions"},{"location":"shocks/#univariate-distributions","text":"","title":"Univariate distributions"},{"location":"shocks/#iid-normal","text":"The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted, thanks to the greek_tolerance function. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu","title":"IID Normal"},{"location":"shocks/#iid-lognormal","text":"Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu","title":"IID LogNormal"},{"location":"shocks/#uniform","text":"Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max","title":"Uniform"},{"location":"shocks/#beta","text":"If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1","title":"Beta"},{"location":"shocks/#bernouilli","text":"Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3","title":"Bernouilli"},{"location":"shocks/#multivariate-distributions","text":"","title":"Multivariate distributions"},{"location":"shocks/#normal-multivariate","text":"Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1]","title":"Normal (multivariate)"},{"location":"shocks/#mixtures","text":"For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. ... exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3])","title":"Mixtures"},{"location":"shocks/#continuous-autoregressive-process","text":"","title":"Continuous Autoregressive Process"},{"location":"shocks/#ar1-var1","text":"For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]]","title":"AR1 / VAR1"},{"location":"shocks/#markov-chains","text":"Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]]","title":"Markov chains"},{"location":"shocks/#product","text":"We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof).","title":"Product"},{"location":"shocks/#conditional-processes","text":"Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]]","title":"Conditional processes"},{"location":"shocks/#discretization-methods-for-continous-shocks","text":"To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Discretization methods for continous shocks"},{"location":"single_agent/","text":"Single-Agent Program Given a vector of aggregate endogenous variables (e.g. wages or interest rates), the program of the single-agent can be solved using traditional methods in computational economics. In DolARK, we use dolo to do so. At this point, the only relevant question concerns the proper writing of the YAML file including these aggregate endogenous variables. The YAML file To be more specific, the introduction of aggregate endogenous variables amends the YAML file in two steps: Aggregate endogenous variables are first declared in the exogenous subsection of the symbols section. We then specify an additional !ConstantProcess entry in the exogenous section to initalize the behavior of aggregate endogenous variables. The rest of the YAML file writes following the documentation of dolo An Example: Aiyagari (1994) Consider the model proposed by Aiyagari (1994). The economy includes one homogeneous good, which is produced with labor and capital. There exists a continuum of households who inelastically supply labor, receive wage w w and face idiosyncratic employment shocks e e . Households may consume c c and save a a , which yields interests at rate r r . Households are credit-constrained ; they cannot borrow beyond a cap \\underline{a} \\underline{a} . An household's value function verifies v_t(k_t) = \\max_{c_t} u(c_t) + \\beta \\mathbb E_t v_{t+1}(k_{t+1}) v_t(k_t) = \\max_{c_t} u(c_t) + \\beta \\mathbb E_t v_{t+1}(k_{t+1}) subject to c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a} c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a} <span><span class=\"MathJax_Preview\">c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a}</span><script type=\"math/tex\">c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a} Firms in perfect competition produce the homogeneous good with a Cobb-Douglas technology and choose inputs to maximize profits. Thus, the representative firm's program is \\max_{K_t,L} A K^\\alpha L^{1-\\alpha} - (r+\\delta) K_t - w L \\max_{K_t,L} A K^\\alpha L^{1-\\alpha} - (r+\\delta) K_t - w L where - K_t K_t is aggregate capital - L L is aggregate labor supply - \\delta \\delta is the depreciation rate of capital - A A is the scale factor of production - \\alpha \\alpha is the output elasticity w.r.t capital The first-order conditions of the firm's program deliver expressions for r r and w w . r = A \\alpha \\left( \\frac{L}{K} \\right)^{1 - \\alpha} - \\delta\\\\ w = A (1-\\alpha) \\left( \\frac{L}{K} \\right)^{\\alpha} r = A \\alpha \\left( \\frac{L}{K} \\right)^{1 - \\alpha} - \\delta\\\\ w = A (1-\\alpha) \\left( \\frac{L}{K} \\right)^{\\alpha} In this example, the aggregate endogenous variables are the interest rate r r and the wage w w . The two modifications stated in the previous paragraph appear 1. in the exogenous subsection of the symbols section looks like symbols: ... exogenous: [r,w,e] ... 2. in the exogenous section exogenous: ... r,w: !ConstantProcess \u03bc: [r, w] ... Overall, , assuming that logged e e follow an AR1 with persistence \\rho = 0.95 \\rho = 0.95 and standard deviation \\sigma = 0.06 \\sigma = 0.06 , the corresponding YAML file looks like symbols: states: [a] exogenous: [r, w, e] parameters: [alpha, L, delta, beta, a_min, a_max] controls: [i] definitions: c: (1+r)*a+w*exp(e) - i equations: arbitrage: - 1-beta*(1+r(+1))*c/c(+1) | -B <= i <= (1+r)*a+w*exp(e) transition: - a = i(-1) calibration: ... r: alpha*(L/K)**(1-alpha) - delta w: (1-alpha)*(K/L)**(alpha) ... domain: a: [a_min, a_max] exogenous: r,w: !ConstantProcess \u03bc: [r, w] e: !VAR1 \u03c1: 0.95 \u03a3: [[0.06**2]] options: grid: !Cartesian orders: [30]","title":"Single Agent"},{"location":"single_agent/#single-agent-program","text":"Given a vector of aggregate endogenous variables (e.g. wages or interest rates), the program of the single-agent can be solved using traditional methods in computational economics. In DolARK, we use dolo to do so. At this point, the only relevant question concerns the proper writing of the YAML file including these aggregate endogenous variables.","title":"Single-Agent Program"},{"location":"single_agent/#the-yaml-file","text":"To be more specific, the introduction of aggregate endogenous variables amends the YAML file in two steps: Aggregate endogenous variables are first declared in the exogenous subsection of the symbols section. We then specify an additional !ConstantProcess entry in the exogenous section to initalize the behavior of aggregate endogenous variables. The rest of the YAML file writes following the documentation of dolo","title":"The YAML file"},{"location":"single_agent/#an-example-aiyagari-1994","text":"Consider the model proposed by Aiyagari (1994). The economy includes one homogeneous good, which is produced with labor and capital. There exists a continuum of households who inelastically supply labor, receive wage w w and face idiosyncratic employment shocks e e . Households may consume c c and save a a , which yields interests at rate r r . Households are credit-constrained ; they cannot borrow beyond a cap \\underline{a} \\underline{a} . An household's value function verifies v_t(k_t) = \\max_{c_t} u(c_t) + \\beta \\mathbb E_t v_{t+1}(k_{t+1}) v_t(k_t) = \\max_{c_t} u(c_t) + \\beta \\mathbb E_t v_{t+1}(k_{t+1}) subject to c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a} c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a} <span><span class=\"MathJax_Preview\">c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a}</span><script type=\"math/tex\">c_t + a_{t+1} = (1+r) a_t + e_t w \\quad \\text{and} \\quad a \\geq \\underline{a} Firms in perfect competition produce the homogeneous good with a Cobb-Douglas technology and choose inputs to maximize profits. Thus, the representative firm's program is \\max_{K_t,L} A K^\\alpha L^{1-\\alpha} - (r+\\delta) K_t - w L \\max_{K_t,L} A K^\\alpha L^{1-\\alpha} - (r+\\delta) K_t - w L where - K_t K_t is aggregate capital - L L is aggregate labor supply - \\delta \\delta is the depreciation rate of capital - A A is the scale factor of production - \\alpha \\alpha is the output elasticity w.r.t capital The first-order conditions of the firm's program deliver expressions for r r and w w . r = A \\alpha \\left( \\frac{L}{K} \\right)^{1 - \\alpha} - \\delta\\\\ w = A (1-\\alpha) \\left( \\frac{L}{K} \\right)^{\\alpha} r = A \\alpha \\left( \\frac{L}{K} \\right)^{1 - \\alpha} - \\delta\\\\ w = A (1-\\alpha) \\left( \\frac{L}{K} \\right)^{\\alpha} In this example, the aggregate endogenous variables are the interest rate r r and the wage w w . The two modifications stated in the previous paragraph appear 1. in the exogenous subsection of the symbols section looks like symbols: ... exogenous: [r,w,e] ... 2. in the exogenous section exogenous: ... r,w: !ConstantProcess \u03bc: [r, w] ... Overall, , assuming that logged e e follow an AR1 with persistence \\rho = 0.95 \\rho = 0.95 and standard deviation \\sigma = 0.06 \\sigma = 0.06 , the corresponding YAML file looks like symbols: states: [a] exogenous: [r, w, e] parameters: [alpha, L, delta, beta, a_min, a_max] controls: [i] definitions: c: (1+r)*a+w*exp(e) - i equations: arbitrage: - 1-beta*(1+r(+1))*c/c(+1) | -B <= i <= (1+r)*a+w*exp(e) transition: - a = i(-1) calibration: ... r: alpha*(L/K)**(1-alpha) - delta w: (1-alpha)*(K/L)**(alpha) ... domain: a: [a_min, a_max] exogenous: r,w: !ConstantProcess \u03bc: [r, w] e: !VAR1 \u03c1: 0.95 \u03a3: [[0.06**2]] options: grid: !Cartesian orders: [30]","title":"An Example: Aiyagari (1994)"}]}